# Summary for V4
Main goals of next release:
- As this library is now in greater use, improve the currently poor baseline performance
- Fix longstanding issues (e.g. ThreadPoolStatsCollector doesn't work)
- Make use of all events currently being collected by current level of verbosity
- Keep compatability with .NET core v3
- Remove support for v2 of prometheus-net
- Fix long-running perf bug


## Improving performance
Main cost involves the .NET runtime producing events, not processing them so we need to be smarter about when we enable the more verbose event sources. Ideas include:
- Using event counters
- Dynamic switching of metric sources

### Using event counters
Event counters should place a much lower stress on the runtime- using these could definitely help.
See https://docs.microsoft.com/en-us/dotnet/core/diagnostics/event-counters#sample-code.

Counter implementation concerns:
- Rate is fixed ahead of time (min frequency = 1 sec)
- Counter values are collected separately from other events (need to provide mechanism for other profilers to consume counter values)
- Perhaps event listeners consume counters?

### Dynamic switching of metric sources
Overall could be three levels of detail for most sources, ordered in terms of perf impact (low -> high):
1. Counters
2. Events (Warning) 
2. Events (info)
3. Events (verbose)

Depending on the information a user wishes to obtain, switching between these three verbosity levels could be useful. Scenarios include:
- Disabling more detailed collectors by default
- Enabling/ disabling collectors as conditions change (e.g. a lot of exceptions are thrown then disable high-impact collection, enabling detailed thread stats when thread pool queue times increase)

```
DotNetRuntimeStatsBuilder.LowestImpact.StartCollecting();
DotNetRuntimeStatsBuilder.AllCollectors.StartCollecting();

Gc.DefaultLevel(Info)
	.Use.Verbose.When(x => x.allocRate > x, 5 second)
	.Use.Info.When(x => x.EventsSec > 100)
	
// Why are we doing this?
// To control performance impact of collectors
// To enable more detail when needed
// TraceInfo, TraceVerbose
// Scenarios: 
// JIT: on startup, when a lot of JIT is happening (e.g. num methods > x)
// Contention: when number of locks contended > 5, when number of locks isn't greater than 5
// GC: when LOH > blah size (enable LOH allocs)
// ThreadPool: When queue length > x, num threads > Environment.ProcessorCount
// Exceptions: When num exceptions> blah

// Levels: Info, Verbose
DotNetRuntimeStatsBuilder.Customize()
	.With.Gc
	.With.Jit
	.With.ThreadPoolStats
		.Use.Detailed.When(x => x.Blah)
		.Use.Detailed.Always()
		.Use.Level(Level.Info)
		.Use.Normal.When(x => x.NumEventsSec > 100)
	.With.ThreadPoolLatencyStats
	
```


IDEAS:
- State change based on repetitive duration of time
- State change based on value of event counters (e.g. bytes jitted > x for y seconds)
- State change based on rate of events received (e.g. > 100/sec, then disable events for x seconds)
- Premade profiles (e.g. perf vs investigation)
- Need to track what collectors are enabled and at what level of verbosity
- Will need to completely redesign the construction of event listeners
- Evaluate every collection (perhaps this will be too long?)
- Counters have to have their refresh frequency specified up front (default to 1 sec?)

- Counters will be updated at a fixed frequency, we can use this to inform judgments
- We need to take samples of the queue length via histogram
- E.g. thread pool, enable detail after we see a queue build up of y
- Collectors should be ignorant of verbosity changes (managed externally)
- Collectors need to expose additional information (e.g. counter values to base judgments on)



## Collector improvements
Overall:
- Make full use of all events captured by current verbosity levels
- Upgrade to the latest version of events

### GC
- Track finalizer processing times
- Track mark events (GcMarkWithType) to track the types of roots that hold memory
- Track pinned object heap size (heapstats v3)
- Track allocations more effeciently (don't use Verbose keyword). Can we support this in V3 of .NET core?
- GCHeapSurvivalAndMovementKeyword to track reserved sizes of heaps and positions
- Look into GCGlobalHeapHistory_V3?
- Track compactions?

### Execeptions
- Track times spent throwing + time spent handling events
- Offer fallback to the count event counter

### JIT
- _ilBytesJittedCounter to track bytes spent
- Offer to track greater verbosity?

### RuntimeInformation?

### [EventSource()] in coreclr
Possible ideas:
- HttpClient (time queued, connection count, etc)
- Dependency injection
- DNS lookups

Ideas to reduce CPU consumpton:
- don't track JIT on startup
- don't track TP stats unless unhealthy (e.g. too many queued tasks)
- don't track contention stats unless lots of contention
- don't track exceptions unless count is 

For each source of info, offer options to:
- increase verbosity (more detailed log events, e.g. alloc by heap)
- upgrade from event counters -> event traces 
- downgrade from event traces -> counters
- disable collectors entirely 

# Collector improvements
## GC
- Collect heap info
